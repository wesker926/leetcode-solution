package com.wesker926.leetcode.algorithms.p1015.s1;

/**
 * @author wesker.gh
 * @date 2023/5/10
 * @description 数论
 * 遍历数字x(1 -> 1..1)，如果x % k = r != 0，则继续判断下一个数字
 * 因为 r2 = x2 % k = (x1 * 10 + 1) % k = ((x1 % k) * 10 + 1) % k = (r1 * 10 + 1) % k
 * 余数r可由前一个余数获得，而余数本身是有限的k个，因此使用哈希表判重即可在有限循环内求得
 * 优化：
 * 2或5的倍数必然无解，而非2或5的倍数必然有解
 * 证明：
 * 因余数种类有限，持续循环必然使余数重复，设mn为对k同余的(1...1)形式数字，设m < n
 * 则 n - m = 1...10...0，其中0可以有0或多个
 * 因为(n - m) % k = n % k - m % k = 0，因此n - m必是k的倍数
 * 因为k不是2或5的倍数，所以k与10互质，n - m如果末尾存在0，则此0不是来自k而是来自另一个因子t(?...?0...0)
 * 移除(n - m)的尾0（等价于移除t的尾0）不影响其为k的倍数，因此尾0去除后得到1...1的形式，即1...1是k的倍数
 * 因此必有解，可以省略哈希表判重
 */
public class Solution {
    public int smallestRepunitDivByK(int k) {
        if ((k & 1) == 0 || (k % 10) == 5) return -1;
        for (int r = 1 % k, c = 1; ; r = (r * 10 + 1) % k, c++) {
            if (r == 0) return c;
        }
    }
}
